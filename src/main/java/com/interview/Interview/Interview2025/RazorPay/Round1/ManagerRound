We have two database servers. Server 1 is hot due to uneven key distribution. Weâ€™re using consistent hashing
to assign keys to servers. To rebalance the load, we add Server 3 and start migrating a portion of Server 1â€™s
data to it.

âš–ï¸ What if we prioritize consistency (CAP)?

â€œIf we want consistency, we should only allow reads/writes to go to the correct authoritative node, even if it delays the response. We may temporarily block writes for a migrating key until ownership is confirmed.â€

â¸»

âš¡ What if we prioritize availability?

â€œIf availability is prioritized, we can accept writes temporarily on either server (e.g., Server 1 or 3), but weâ€™ll need a conflict resolution strategy or eventual consistency mechanism later.â€


â€œWhen weâ€™re migrating data from Server 1 to Server 3 â€” even though the servers are online â€” the situation is conceptually similar to a data partition, which resembles a network partition from a CAP theorem perspective.

In such a scenario, we must make a choice:
	â€¢	Do we prioritize consistency, ensuring only one server handles a given key, even if that makes some keys temporarily unavailable?
	â€¢	Or do we prioritize availability, allowing both servers to read/write, accepting the risk of inconsistent state that needs reconciliation?

Since weâ€™re working with a SQL DB with ACID guarantees, the safe answer is:
	â€¢	Only one server (the owner of the key) should accept reads and writes during migration.
	â€¢	The system needs a routing layer or metadata table to determine if a key is still on Server 1 or has moved to Server 3.
	â€¢	Reads/writes should always go to the authoritative location. If thatâ€™s not known, better to delay the operation than risk inconsistency.â€

â¸»

ğŸ” Use of Partition Concept

â€œSo even though itâ€™s a controlled data migration, the CAP trade-off is real â€” the system is essentially in a temporary partitioned state, and we must decide:
	â€¢	Do we block operations until weâ€™re sure where the key lives (Consistency)?
	â€¢	Or do we accept requests anyway and deal with conflicts later (Availability)?

Since itâ€™s a SQL system with ACID constraints, we choose consistency.â€



so basically we need a downtime for server 1
â€œHow can we utilize downtime so that reads and writes are consistent during continuous data migration?â€
